---
title: "R Notebook"
output: html_notebook
---

## Set-up libraries and prepare for data import: 
```{r}
library(psych)
library(likert)
library(tidyverse)
library(jsonlite)
library(ggplot2)
library(mosaic)
source("http://pcwww.liv.ac.uk/~william/R/crosstab.r")
theme_set(theme_classic())
```

## Set-up directories, import and clean data: 
```{r}
rm(list=ls())
setwd("/Users/allieblaising/desktop/bang/R") 
getwd()
dataPath = "../.data"
## Define function to extract survey results: 
extractSurvey = function(frame,survey) {
  rounds = seq(1,length(frame$results.format[[1]]))
  roundResponses = lapply(rounds, function(round) {
    getCol = paste("results.",survey,".",round, sep="")
    surveyCols = Filter(function(x) grepl(getCol,x),names(frame))
    newCols = lapply(surveyCols, function(x) gsub(getCol,paste("results.",survey, sep=""),x) )
    surveyFrame = frame[,surveyCols]
    if (is.null(newCols)) {return("No newCols")}
    names(surveyFrame) = newCols
    surveyFrame$id = frame$id
    surveyFrame$round = round
    surveyFrame$batch = frame$batch
    surveyFrame$rooms = frame$rooms
    surveyFrame$manipulation = frame$results.manipulationCheck
    surveyFrame$blacklist = frame$results.blacklistCheck
    return(surveyFrame)
  })
  return(Reduce(rbind,roundResponses))
}
#Find directory for import (be sure to verify that batch #s align from bangData import and imports below): 
batches = dir(dataPath, pattern = "^[0-9]+$" )
completeBatches = Filter(function(batch) { 
  if (any(dir(paste(dataPath,batch,sep="/")) == "batch.json") && (any(dir(paste(dataPath,batch,sep="/")) == "users.json")) ) {
    batchData = read_json(paste(dataPath,batch,"batch.json",sep="/"), simplifyVector = TRUE)
    return(any(batchData$batchComplete == TRUE))
  } 
  return(FALSE)
}, batches)
userFiles = lapply(completeBatches, function(batch) {
  userFile = read_json(paste(dataPath,batch,"users.json",sep="/"), simplifyVector = TRUE)
  return(flatten(userFile, recursive = TRUE))
})
## Retroactively find rooms from chat data: 
overlappingFiles = Reduce(function(x,y) merge(x, y, all=TRUE), userFiles)
roundsWithRooms = apply(overlappingFiles,1,function(x) {
  roomsForIndividual = lapply(seq(1,3),function(y) {
    x$room = x$rooms[y]
    x$round = y
    return(x)
  })
  return(Reduce(rbind,roomsForIndividual))
})
```

## More cleaning before visualizations: 
```{r}
## Apply extract survey function to extract the right columns and rows for viability survey: 
survey = 'viabilityCheck'
frame <- extractSurvey(overlappingFiles, survey)
## Reduce to vertically combine rows in roundwithRooms list:  
finalRounds = as.data.frame(Reduce(rbind,roundsWithRooms))
## Subset incomplete cases from viability survey dataframe: 
## MSB: complete.cases doesn't work when there aren't NAs, but empty lists, alternatives rather than subsetting where 
## blacklist is empty? Doens't work: test <- complete.cases(data)
data <- frame[frame$manipulation!="",]
## Rename room to rooms so that both are retained in future merge: 
data <- rename(data, rooms = "rooms")
## Subset incomplete cases for final rounds dataframe: 
data2 <- finalRounds[finalRounds$results.manipulationCheck!="", ]
## Select only variables of interest from final rounds: 
data2 = data2 %>% select(id, batch, room, bonus, name, friends, 
                         friends_history, results.condition, results.format,
                         results.manipulation,results.manipulationCheck,results.blacklistCheck, round)
## Convert to compatible data types before merge (this should be simplified)
data2$batch <- unlist(data2$batch)
data$batch <- unlist(data$batch)
data2$round <- unlist(data2$round)
data2$id <- unlist(data2$id)
## Before merge, data and data2 should ahve the same # of observations
## Merge columns by id, round and batch #s: 
data <- left_join(data, data2, by=NULL)
## Subset only observations with batch #s in complete batches 
allConditions <- data[data$batch %in% completeBatches, ]
```
## Conditionally assign conditions based on treatment and results column: 
```{r}
## Messy, but robust? Verify, verify, verify.  
data <- data %>% mutate(
  condition = case_when(
    results.condition=='treatment' & results.format=="c(1, 2, 1)" & round==1 ~ "A", 
    results.condition=='treatment' & results.format=="c(1, 2, 1)" & round==2 ~ "B", 
    results.condition=='treatment' & results.format=="c(1, 2, 1)" & round==3 ~ "Ap", 
    results.condition=='treatment' & results.format=="c(1, 1, 2)" & round==1 ~ "A", 
    results.condition=='treatment' & results.format=="c(1, 1, 2)" & round==2 ~ "Ap", 
    results.condition=='treatment' & results.format=="c(1, 1, 2)" & round==3 ~ "B", 
    results.condition=='treatment' & results.format=="c(2, 1, 1)" & round==1 ~ "B", 
    results.condition=='treatment' & results.format=="c(2, 1, 1)" & round==2 ~ "A", 
    results.condition=='treatment' & results.format=="c(2, 1, 1)" & round==3 ~ "Ap" ,
    results.condition=='control' & results.format=="c(1, 2, 1)" & round==1 ~ "A", 
    results.condition=='control' & results.format=="c(1, 2, 1)" & round==2 ~ "B", 
    results.condition=='control' & results.format=="c(1, 2, 1)" & round==3 ~ "Ap", 
    results.condition=='control' & results.format=="c(1, 1, 2)" & round==1 ~ "A", 
    results.condition=='control' & results.format=="c(1, 1, 2)" & round==2 ~ "Ap", 
    results.condition=='control' & results.format=="c(1, 1, 2)" & round==3 ~ "B", 
    results.condition=='control' & results.format=="c(2, 1, 1)" & round==1 ~ "B", 
    results.condition=='control' & results.format=="c(2, 1, 1)" & round==2 ~ "A", 
    results.condition=='control' & results.format=="c(2, 1, 1)" & round==3 ~ "Ap" , 
    results.condition=='baseline' & results.format=="c(1, 2, 3)" & round==1 ~ "A" ,
    results.condition=='baseline' & results.format=="c(1, 2, 3)" & round==2 ~ "B" ,
    results.condition=='baseline' & results.format=="c(1, 2, 3)" & round==3 ~ "C" 
  )) 
```

## Set-up for factors for viability questions: 
```{r}
data <- rename(data, "repeatTeam" = results.viabilityCheck.15)
## Remove observations where viability survey wasn't on (remove this line if we want to keep observations with viability off): 
data <- na.omit(data)
levels <- c("Strongly Disagree", "Disagree", "Neutral","Agree", "Strongly Agree") 
clean <- data %>% 
  mutate_at(.vars = vars(contains("results.viabilityCheck")), funs(factor(., levels = levels))) 
## Viabilitylikert visuals: 
## Subset only viabilitySurvey columns and condition column (condition column used to visualize likert responses for conditions)
viabilityLikert <- select(clean, contains("results.viabilityCheck"), "condition", "results.condition")
viabilityLabels = c("1. The members of this team could work for a long time together" 
                    , "2. Most of the members of this team would welcome the opportunity to work as a group again in the future." , 
                    "3. This team has the capacity for long-term success.", 
                    "4. This team has what it takes to be effective in the future.", 
                    "5. This team would work well together in the future." , 
                    " 6. This team has positioned itself well for continued success.",  
                    " 7. This team has the ability to perform well in the future. ", 
                    " 8. This team has the ability to function as an ongoing unit." , 
                    " 9. This team should continue to function as a unit. ", 
                    " 10. This team has the resources to perform well in the future. ", 
                    " 11. This team is well positioned for growth over time. ", 
                    " 12. This team can develop to meet future challenges. ", 
                    " 13. This team has the capacity to sustain itself. ", 
                    " 14. This team has what it takes to endure in future performance episodes.", "condition", "results.condition") 
names(viabilityLikert) <- rep(viabilityLabels) 
```

## Likert visualizations: 
```{r}
## Likert graph for all viability responses across all conditions (i.e. baseline, control and treatment): 
likert.out <- likert(viabilityLikert[-c(15:16)]) 
plot(likert.out)
## Subset A and Ap (i.e. A prime) responses for treatment group: 
# Treatment + A: 
treatmentA <- viabilityLikert %>% filter(condition=="A" & results.condition=="treatment") 
likert.treatmentA <- likert(treatmentA[-c(15:16)])
plot(likert.treatmentA)
# Treatment + Ap: 
treatmentAp <- viabilityLikert %>% filter(condition=="Ap" & results.condition=="treatment") 
likert.treatmentAp <- likert(treatmentA[-c(15:16)])
plot(likert.treatmentAp)
# Treatment + B: 
treatmentAp <- viabilityLikert %>% filter(condition=="B" & results.condition=="treatment") 
likert.treatmentAp <- likert(treatmentA[-c(15:16)])
plot(likert.treatmentAp)
## Customize code above to filter on other conditions and treatments of interest. 
```

## Exploratory data analysis part #1: 
```{r}
## Create a new dataframe that converts factors to numeric for statistical analyses: 
stats <- clean %>% mutate_if(is.factor, as.numeric)
for (i in 1:nrow(stats)) {
  stats$sum[i] <- sum(stats[i,1:14])                          
} 
stats$median <- median(stats$sum)
stats$mean <- mean(stats$sum)
## Revalue repeat team: keep plyr b/c some weird R stuff requires library to be called directly: 
stats$repeatTeam <- plyr::revalue(stats$repeatTeam, c("Yes"="1", "No"="0"))
stats$repeatTeam <- plyr::revalue(stats$repeatTeam, c("Keep this team"="1", "Do not keep this team"="0"))
## Convert to compatible classes for grouping: 
stats$repeatTeam <- as.numeric(stats$repeatTeam)
stats$results.condition <- unlist(stats$results.condition)
stats$results.format <- as.character(stats$results.format)
stats$room <- unlist(stats$room)
## Dplyr to group teams and summarise variables for each group: 
groupedProportion <- stats %>%
  group_by(room, batch, round, condition, results.condition, results.format) %>% 
  summarise(n=n(), mean=mean(sum), median=median(sum),prop=sum(repeatTeam)/n) %>% 
  filter(n>1)
## Individual proportion: 
individualProportion <- stats %>% group_by(round, batch, room) %>% 
  mutate(sum=sum, mean=mean(sum), median=median(sum), n=n(),prop=sum(repeatTeam)/n) %>% filter(n>1)
## Table showing how many teams we've run in each condition combination:  
table(groupedProportion$condition, groupedProportion$results.condition)
```

## Exploratory data analysis part #2: 
```{r}
## Plot of prop and mean per group with standard error: 
ggplot(groupedProportion, aes(x=prop, y=mean)) + 
  geom_point() +
  stat_smooth(method = "lm", col = "red") + 
  labs(subtitle="", 
       x="Distribution of responses to Q15: ",
       y="Numeric sum of viability measures questions (range: 7-70)") + facet_grid(condition ~ results.format)

## Unlist for condition for graph: 
groupedProportion$results.condition <- unlist(groupedProportion$results.condition)
## Team viability sum and Q15 factor repeat team answers facet_grid by condition, results.condition and results.format (all users) 
g <- ggplot(stats, aes(factor(repeatTeam), sum))
g + geom_boxplot(varwidth=T, fill="plum") + 
  labs(subtitle="Sum of viability measures grouped by repeat team question:", 
       x="Distribution of responses to Q15: ",
       y="Numeric sum of viability measures questions (range: 7-70)") + facet_grid(condition ~ results.format)

## Team viability mean and repeat team answers facet_grid by results.condition, condition and results.format 
g <- ggplot(stats, aes(factor(repeatTeam), mean))
g + geom_boxplot(varwidth=T, fill="plum") + 
  labs(subtitle="Mean of viability measures grouped by repeat team question across all conditions", 
       x="Distribution of responses to Q15",
       y="Numeric sum of viability measures questions (range: 7-70)") + facet_grid(condition ~ results.format)

g <- ggplot(stats, aes(factor(repeatTeam), sum))
g + geom_boxplot(varwidth=T, fill="plum") + 
  labs(subtitle="Sum of viability measures grouped by repeat team question:", 
       x="If you had the choice, would you like to work with the same team in a future round? 1=Yes, 0=No",
       y="Numeric sum of viability measures questions (range: 7-70)") + facet_grid(condition ~ results.condition)

ggplot(groupedProportion, aes(x=prop, y=mean)) + 
  geom_point() +
  stat_smooth(method = "lm", col = "red")  + facet_grid(condition ~ results.condition) + 
  labs(title="Team fracture proportion vs. mean viability", 
                                  x="Proportion for Q15: 1=Yes , 0=No", y="Count") 

## Mean vs. median plot for viability sums per team: 
ggplot(groupedProportion, aes(x=mean, y=median)) + 
  geom_point() +
  stat_smooth(method = "lm", col = "red") + labs(main="Scatterplot of median vs. mean for team viability sums")

ggplot(data=groupedProportion, aes(groupedProportion$prop)) + 
  geom_histogram(breaks=seq(0, 1, by=0.20), 
                 col="red", 
                 fill="green", 
                 alpha=.2) + labs(title="Binary proportion of answers for question 15 per team (team size range: 2-4)", 
                                  x="If you had the choice, would you like to work with the same team in a future round? 
                                  1=Yes , 0=No", y="Count") + facet_grid(condition ~ results.format)

ggplot(data=individualProportion, aes(individualProportion$prop)) + 
  geom_histogram(breaks=seq(0, 1, by=0.20), 
                 col="red", 
                 fill="green", 
                 alpha=.2) + labs(title="Binary proportion of answers for question 15 per team: n=##fill-in observations",
                                  x="If you had the choice, would you like to work with the same team in a future round? 
                                  1=Yes , 0=No", y="Count") + facet_grid(condition ~ results.format)


ggplot(data=groupedProportion, aes(groupedProportion$prop)) + 
  geom_histogram(breaks=seq(0, 1, by=0.20), 
                 col="red", 
                 fill="green", 
                 alpha=.2) + labs(title="Binary proportion of answers for question 15 per team (team size range: 2-4)", 
                                  x="If you had the choice, would you like to work with the same team in a future round? 
                                  1=Yes , 0=No", y="Count") + facet_grid(condition ~ results.condition)

```

## Probability of fracture across teams and condition combinations: 
```{r}
## Define cut-off point for fracture: 
groupedProportionFracture <- groupedProportion %>%
  group_by(results.condition, condition) %>% 
  mutate(fracture = case_when (prop<=.50 ~ "0", 
                                prop>.50~ "1"))

tally(~condition + fracture, data = groupedProportionFracture, format = "proportion")
tally(~fracture | condition, data = groupedProportionFracture, format = "proportion")
```

## Fracture proportion scatterplots: 
```{r}
## Learning effect: 
groupedProportionFractureLE <- groupedProportionFracture %>% filter(results.format=="c(1, 1, 2)" | results.format=="c(2, 1, 1)") 
groupedProportionFractureLE <- groupedProportionFractureLE %>% filter(round=="1" | round=="3")

fractureLE1 <- groupedProportionFractureLE %>% filter(round=="1")
fractureLE2 <- groupedProportionFractureLE %>% filter(round=="3")
fractureLE1$prop <- 1-fractureLE1$prop
fractureLE2$prop <- 1-fractureLE2$prop
fractureLE <- cbind(fractureLE1, fractureLE2)


ggplot(data=groupedProportionFractureTreatment, aes(prop)) + 
  geom_histogram(breaks=seq(0, 1, by=0.20), 
                 col="red", 
                 fill="green", 
                 alpha=.2) + labs(title="Team fracture in the first round vs. the experimental round in the treatment condition",
                                  x="Fracture proportion
                                  1=Yes , 0=No", y="Count") + facet_grid(. ~ condition)


ggplot(data=groupedProportionFractureControl, aes(prop)) + 
  geom_histogram(breaks=seq(0, 1, by=0.20), 
                 col="red", 
                 fill="green", 
                 alpha=.2) + labs(title="Team fracture in the first round vs. the control condition",
                                  x="Fracture proportion
                                  1=Yes , 0=No", y="Count") + facet_grid(. ~ condition)

ggplot(data=groupedProportionFractureLE, aes(prop)) + 
  geom_histogram(breaks=seq(0, 1, by=0.20), 
                 col="red", 
                 fill="green", 
                 alpha=.2) + labs(title="Team fracture in the first round vs. the third round in the learning effect condition",
                                  x="Fracture proportion
                                  1=Yes , 0=No", y="Count") + facet_grid(. ~ round)



ggplot(treatmentFracture, aes(prop)) +
  geom_point(aes()) +
  geom_jitter() + coord_fixed() + xlim(0.0,1.0) + ylim(0.0,1.0) + labs(title="Team fracture in the first round vs. third in the experimental condition:  n=34 teams", subtitle="Fracture scale 0=no fracture, 1=fracture",  
       x="Fracture the first time a team interacts", 
       y="Fracture the second time a team interacts, without knowing it") 

## Treatment: 
groupedProportionFractureTreatment <- groupedProportionFracture %>% 
filter(results.condition=="treatment")
treatmentFracture1 <- groupedProportionFractureTreatment %>% filter(condition=="A")
treatmentFracture2 <- groupedProportionFractureTreatment %>% filter(condition=="Ap")
treatmentFracture1$prop1 <- 1-treatmentFracture1$prop
treatmentFracture2$prop2 <- 1-treatmentFracture2$prop
treatmentFracture <- cbind(treatmentFracture1, treatmentFracture2)

ggplot(treatmentFracture, aes(prop1, prop2)) +
  geom_point() +
  geom_jitter() + coord_fixed() + xlim(0.0,1.0) + ylim(0.0,1.0) + labs(title="Team fracture in the first round vs. third in the experimental condition:  n=34 teams", subtitle="Fracture scale 0=no fracture, 1=fracture",  
       x="Fracture the first time a team interacts", 
       y="Fracture the second time a team interacts, without knowing it")+  facet_grid(. ~ condition)

## Control:  
groupedProportionFractureControl <- groupedProportionFracture %>% 
  filter(results.condition=="control") 
controlFracture1 <- groupedProportionFractureControl %>% filter(condition=="A")
controlFracture2 <- groupedProportionFractureControl %>% filter(condition=="Ap")
controlFracture1$prop <- 1-controlFracture1$prop
controlFracture2$prop <- 1-controlFracture2$prop
controlFracture <- cbind(controlFracture1, controlFracture2)

ggplot(controlFracture, aes(prop, prop1)) +
  geom_point() +
  geom_jitter() + coord_fixed() + xlim(0.0,1.0) + ylim(0.0,1.0) + labs(title="Team fracture in the first vs. third in the second, control round: n=7 teams", subtitle="Fracture scale 0=no fracture, 1=fracture",  
                                                                       x="Fracture the first time a team interacts", 
                                                                       y="Fracture the second time a team interacts, without knowing it") 

## Fracture initial: true, false 
## Fracture Ap: flipped: true, false 
## Treatment, 

sum(groupedProportionFractureTreatment$prop1)
sum(groupedProportionFracture$prop)

## Defining fracture: 

## TREATMENT EFFECT: 
## Overall fracture change: 
sum(ifelse(treatmentFracture1$fracture==treatmentFracture2$fracture,0,1)) 
# Results: 17/34 ~50% 
## No fracture to fractre: 
sum(ifelse(treatmentFracture1$fracture==0 & treatmentFracture2$fracture==1,1,0))
# Results: 11/34 ~32% 

## CONTROL EFFECT: 
## Overall fracture change: 
sum(ifelse(controlFracture1$fracture==controlFracture2$fracture,0,1))
## Results: 1/7 ~0.14% 
## No fracture to fracture: 
sum(ifelse(controlFracture1$fracture==0 & controlFracture2$fracture==1,1,0))
##  Results: 0/7 0% 

## LEARNING EFFECT 
## Overall fracture change: 
sum(ifelse(fractureLE1$fracture==fractureLE2$fracture,0,1))
# Results: 11/21 ~ 52% 
## No fracture to fracture: 
sum(ifelse(fractureLE1$fracture==0 & fractureLE2$fracture==1,1,0))
# Results: 5/21 ~24% 
  
```

## Histogram comparisons of fracture ratios across treatment, control and learning effect conditions

```{r}
ggplot(data=groupedProportionFracture, aes(fracture)) + 
  geom_bar(breaks=seq(0, 1, by=0.20), 
                 col="red", 
                 fill="green", 
                 alpha=.2) + labs(title="Fracture ratios: treatment condition") + facet_grid(condition ~ results.condition)

ggplot(data=groupedProportionFractureControl, aes(fracture)) + 
  geom_bar(breaks=seq(0, 1, by=0.20), 
                 col="red", 
                 fill="green", 
                 alpha=.2) + labs(title="Fracture ratios: control round") + facet_grid(condition ~ results.condition)

ggplot(data=groupedProportionFractureLE, aes(fracture)) + 
  geom_bar(breaks=seq(0, 1, by=0.20), 
                 col="red", 
                 fill="green", 
                 alpha=.2) + labs(title="Fracture ratios: learning effect condition") + facet_grid(results.condition ~ round)

```

## Graphs for mean distrbution per treatment condition: 

```{r}
## Mean viability distribution graph: treatment condition, A group 
barfill <- "#4271AE"
barlines <- "#1F3552"
## Mean for treatment and A group: ##fill-in) 
meanDistributionTreatmentA <- ggplot(treatmentAStats, aes(x = sum)) +
  geom_histogram(aes(y = ..count..), binwidth = 5,
                 colour = barlines, fill = barfill) +
  scale_x_continuous(name = "Median viability sum",
                     breaks = seq(0, 100, 20),
                     limits=c(0, 70)) +
  scale_y_continuous(name = "count") +
  ggtitle("Frequency of sum of viability scores: N=##fill-in") +
  theme_bw() +
  theme(axis.line = element_line(size=1, colour = "black"),
        panel.grid.major = element_line(colour = "#d3d3d3"),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(), panel.background = element_blank(),
        plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
        text=element_text(family="Tahoma"),
        axis.text.x=element_text(colour="black", size = 9),
        axis.text.y=element_text(colour="black", size = 9)) +
  geom_vline(xintercept = ##fill-in, size = 1, colour = "#FF3721",
               linetype = "dashed")
meanDistributionTreatmentA

## Mean viability distribution graph: treatment condition, Aprime group 
## Mean for treatment condition, Aprime group: (fill-in)
meanDistributionTreatmentAp <- ggplot(treatmentApStats, aes(x = sum)) +
  geom_histogram(aes(y = ..count..), binwidth = 5,
                 colour = barlines, fill = barfill) +
  scale_x_continuous(name = "Median viability sum",
                     breaks = seq(0, 100, 20),
                     limits=c(0, 70)) +
  scale_y_continuous(name = "count") +
  ggtitle("Frequency of sum of viability scores:N=##fill-in") +
  theme_bw() +
  theme(axis.line = element_line(size=1, colour = "black"),
        panel.grid.major = element_line(colour = "#d3d3d3"),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(), panel.background = element_blank(),
        plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
        text=element_text(family="Tahoma"),
        axis.text.x=element_text(colour="black", size = 9),
        axis.text.y=element_text(colour="black", size = 9)) +
  geom_vline(xintercept = ##fill-in, size = 1, colour = "#FF3721",
               linetype = "dashed")
meanDistributionTreatmentAp

## Mean viability distribution graph: treatment condition, B group 
## Mean for treatment condition, B group: 
barfill <- "#4271AE"
barlines <- "#1F3552"
meanDistributionTreatmentB <- ggplot(treatmentBStats, aes(x = sum)) +
  geom_histogram(aes(y = ..count..), binwidth = 5,
                 colour = barlines, fill = barfill) +
  scale_x_continuous(name = "Median viability sum \n across all teams in masked round",
                     breaks = seq(0, 98, 14),
                     limits=c(7, 70)) +
  scale_y_continuous(name = "count") +
  ggtitle("Frequency of sum of viability scores: masked condition, N=##fill-in") +
  theme_bw() +
  theme(axis.line = element_line(size=1, colour = "black"),
        panel.grid.major = element_line(colour = "#d3d3d3"),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(), panel.background = element_blank(),
        plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
        text=element_text(family="Tahoma"),
        axis.text.x=element_text(colour="black", size = 9),
        axis.text.y=element_text(colour="black", size = 9)) +
  geom_vline(xintercept = ##fill-in, size = 1, colour = "#FF3721",
               linetype = "dashed") 
meanDistributionTreatmentB
```

## Chat data: 
```{r}
chatFiles = lapply(completeBatches, function(batch){
    chatFile = read_json(paste(dataPath,batch,"chats.json",sep="/"), simplifyVector = TRUE)
    return(flatten(chatFile, recursive = TRUE))
  })

allChatFiles <- plyr::ldply(chatFiles, data.frame)
chatFreq <- allChatFiles  %>%
  group_by(round, room, batch) %>% 
  dplyr::summarise(n=n()) %>% 
  filter(n>1, round<=2)

## Filter on round <=2, because round 3 in all but one case is only includes "X has left chat room" 

# Histogram grouped by round: 
g <- ggplot(chatFreq, aes(n)) + scale_fill_brewer(palette = "Spectral")
g + geom_histogram(aes(fill=factor(round)), 
                   bins=5, 
                   col="black", 
                   size=.1) +   # change number of bins
  labs(title="Histogram of the number of chat lines per team (includes teams with n=1)", 
       fill = "Round") + 
  xlab(label="Number of lines from chat data per team") + 
  ylab(label="Count") 
stats$room <- unlist(stats$room) 
chatFreqStats <- right_join(x=chatFreq, y=stats)
```

## Conditional probabilities: 
```{r}
groupedProportionFractureTreatment %>% 
  group_by(condition) %>% 
  summarise(n=n(), count=count(fracture)) 

# P(F3|F1) 
p1 <-  19 / 34

# P(notF3|F1) 
p2 <-  15 / 34

# P(F3|F1)
p3 <- 24 / 34

## P(notF3|F1)
p4 <- 10 / 34

  # Print out the probabilities
round(c(p1, p2, p3, p4), digits = 2)  


```



