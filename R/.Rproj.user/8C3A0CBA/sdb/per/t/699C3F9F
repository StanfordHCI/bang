{
    "collab_server" : "",
    "contents" : "## Set-up libraries and prepare for data import: \nlibrary(psych)\nlibrary(likert)\nlibrary(tidyverse)\nlibrary(jsonlite)\nlibrary(ggplot2)\ntheme_set(theme_classic())\n\n## WARNING: make sure that plyr is detached before running dplyr stuff, other you're going to sit at your computer \n## banging your head like I did, so....[detach(package:plyr) library(dplyr)]\n\nrm(list=ls())\n## Change working directory: \nsetwd(\"/Users/allieblaising/desktop/bang/R\") \ngetwd()\ndataPath = \"../.data\"\n\n## Define function to extract survey results: \nextractSurvey = function(frame,survey) {\n  rounds = seq(1,length(frame$results.format[[1]]))\n  roundResponses = lapply(rounds, function(round) {\n    getCol = paste(\"results.\",survey,\".\",round, sep=\"\")\n    surveyCols = Filter(function(x) grepl(getCol,x),names(frame))\n    newCols = lapply(surveyCols, function(x) gsub(getCol,paste(\"results.\",survey, sep=\"\"),x) )\n    surveyFrame = frame[,surveyCols]\n    if (is.null(newCols)) {return(\"No newCols\")}\n    names(surveyFrame) = newCols\n    surveyFrame$id = frame$id\n    surveyFrame$round = round\n    surveyFrame$batch = frame$batch\n    surveyFrame$rooms = frame$rooms\n    surveyFrame$blacklist = frame$results.blacklistCheck\n    return(surveyFrame)\n  })\n  return(Reduce(rbind,roundResponses))\n}\n\n#Find directory for import (be sure to verify that batch #s align from bangData import and imports below): \nbatches = dir(dataPath, pattern = \"^[0-9]+$\" )\ncompleteBatches = Filter(function(batch) { \n  if (any(dir(paste(dataPath,batch,sep=\"/\")) == \"batch.json\") && (any(dir(paste(dataPath,batch,sep=\"/\")) == \"users.json\")) ) {\n    batchData = read_json(paste(dataPath,batch,\"batch.json\",sep=\"/\"), simplifyVector = TRUE)\n    return(any(batchData$batchComplete == TRUE))\n  } \n  return(FALSE)\n}, batches)\n\nuserFiles = lapply(completeBatches, function(batch) {\n  userFile = fromJSON(paste(dataPath,batch,\"users.json\",sep=\"/\"), flatten = TRUE) \n  return(flatten(userFile, recursive = TRUE)) \n})\n\nggplot(fracture, aes(prop, prop1)) +\n  geom_point() +\n  geom_jitter() + coord_fixed() + xlim(0.0,1.0) + ylim(0.0,1.0) + labs(title=\"Team fracture in the first round vs. fracture in the experimental round\", subtitle=\"Fracture scale 0=no fracture, 1=fracture\",  \n                                                                       x=\"Fracture the first time a team interacts\", \n                                                                       y=\"Fracture the second time a team interacts, without knowing it\") \n\n## Retroactively find rooms from chat data: \noverlappingFiles = Reduce(function(x,y) merge(x, y, all=TRUE), userFiles)\nroundsWithRooms = apply(overlappingFiles,1,function(x) {\n  roomsForIndividual = lapply(seq(1,3),function(y) {\n    x$room = x$rooms[y]\n    x$round = y\n    return(x)\n  })\n  return(Reduce(rbind,roomsForIndividual))\n})\n\nggplot(controlFracture, aes(prop, prop1)) +\n  geom_point() +\n  geom_jitter() + coord_fixed() + xlim(0.0,1.0) + ylim(0.0,1.0) + labs(title=\"Team fracture in the first round vs. fracture in the second control round\", subtitle=\"Fracture scale 0=no fracture, 1=fracture\",  \n                                                                       x=\"Fracture the first time a team interacts\", \n                                                                       y=\"Fracture the second time a team interacts, without knowing it\") \n\n\n## Apply extract survey function to extract the right columns and rows for viability survey: \nsurvey = 'viabilityCheck'\nframe <- extractSurvey(overlappingFiles, survey)\n## Reduce to vertically combine rows in roundwithRooms list:  \nfinalRounds = as.data.frame(Reduce(rbind,roundsWithRooms))\n\n## Subset incomplete cases from viability survey dataframe: \n## MSB: complete.cases doesn't work when there aren't NAs, but empty lists, alternatives rather than subsetting where \n## blacklist is empty? Doens't work: test <- complete.cases(data)\ndata <- frame[frame$blacklist!=\"\",]\n## Rename room to rooms so that both are retained in future merge: \ndata <- rename(data, rooms = \"room\")\n\n## Subset incomplete cases for final rounds dataframe: \ndata2 <- finalRounds[finalRounds$results.blacklistCheck!=\"\", ]\n\n## Select only variables of interest from final rounds: \ndata2 = data2 %>% select(id, batch, room, bonus, name, friends, \n                         friends_history, results.condition, results.format,\n                         results.manipulation,results.manipulationCheck,results.blacklistCheck, round)\n\n## Convert to compatible data types before merge (this should be simplified)\ndata$round <- unlist(data$round)\ndata2$batch <- unlist(data2$batch)\ndata$batch <- unlist(data$batch)\ndata2$round <- unlist(data2$round)\ndata2$id <- unlist(data2$id)\n## Before merge, data and data2 should ahve the same # of observations\n## Merge columns by id, round and batch #s: \ndata <- left_join(data, data2, by=NULL)\n## Subset only observations with batch #s in complete batches \nallConditions <- data[data$batch %in% completeBatches, ]\n\n## Conditionally assign conditions based on treatment and results column: \n\n##MSB: below works, but massive and precarious. Ideas for setting up conditional data table to read it? \n\n## For format to be read in properly, we need to make format a character vector: \ndata$results.format <- as.character(data$results.format)\n\n## If we keep this // MSB can't come up with a better approach, we need like everyone to triple check this matches with our \n## code book. \n\ndata <- data %>% mutate(\n  condition = case_when(\n    results.condition=='treatment' & results.format==\"c(1, 2, 1)\" & round==1 ~ \"A\", \n    results.condition=='treatment' & results.format==\"c(1, 2, 1)\" & round==2 ~ \"B\", \n    results.condition=='treatment' & results.format==\"c(1, 2, 1)\" & round==3 ~ \"Ap\", \n    results.condition=='treatment' & results.format==\"c(1, 1, 2)\" & round==1 ~ \"A\", \n    results.condition=='treatment' & results.format==\"c(1, 1, 2)\" & round==2 ~ \"Ap\", \n    results.condition=='treatment' & results.format==\"c(1, 1, 2)\" & round==3 ~ \"B\", \n    results.condition=='treatment' & results.format==\"c(2, 1, 1)\" & round==1 ~ \"B\", \n    results.condition=='treatment' & results.format==\"c(2, 1, 1)\" & round==2 ~ \"A\", \n    results.condition=='treatment' & results.format==\"c(2, 1, 1)\" & round==3 ~ \"Ap\" ,\n    results.condition=='control' & results.format==\"c(1, 2, 1)\" & round==1 ~ \"A\", \n    results.condition=='control' & results.format==\"c(1, 2, 1)\" & round==2 ~ \"B\", \n    results.condition=='control' & results.format==\"c(1, 2, 1)\" & round==3 ~ \"A\", \n    results.condition=='control' & results.format==\"c(1, 1, 2)\" & round==1 ~ \"A\", \n    results.condition=='control' & results.format==\"c(1, 1, 2)\" & round==2 ~ \"A\", \n    results.condition=='control' & results.format==\"c(1, 1, 2)\" & round==3 ~ \"B\", \n    results.condition=='control' & results.format==\"c(2, 1, 1)\" & round==1 ~ \"B\", \n    results.condition=='control' & results.format==\"c(2, 1, 1)\" & round==2 ~ \"A\", \n    results.condition=='control' & results.format==\"c(2, 1, 1)\" & round==3 ~ \"A\" , \n    results.condition=='baseline' & results.format==\"c(1, 2, 3)\" & round==1 ~ \"A\" ,\n    results.condition=='baseline' & results.format==\"c(1, 2, 3)\" & round==2 ~ \"B\" ,\n    results.condition=='baseline' & results.format==\"c(1, 2, 3)\" & round==3 ~ \"C\" \n  )) \n\n## Assign factor levels for survey and graph visualizations: \ndata <- rename(data, \"repeatTeam\" = results.viabilityCheck.15)\n## Remove observations where viability survey wasn't on: \ndata <- na.omit(data)\nlevels <- c(\"Strongly Disagree\", \"Disagree\", \"Neutral\",\"Agree\", \"Strongly Agree\") \nclean <- data %>% \n  mutate_at(.vars = vars(contains(\"results.viabilityCheck\")), funs(factor(., levels = levels)))  \n\n## Viabilitylikert visuals: \n## Subset only viabilitySurvey columns and condition column (condition column used to visualize likert responses for conditions)\nviabilityLikert <- select(clean, contains(\"results.viabilityCheck\"), \"condition\", \"results.condition\")\nviabilityLabels = c(\"1. The members of this team could work for a long time together\" \n                    , \"2. Most of the members of this team would welcome the opportunity to work as a group again in the future.\" , \n                    \"3. This team has the capacity for long-term success.\", \n                    \"4. This team has what it takes to be effective in the future.\", \n                    \"5. This team would work well together in the future.\" , \n                    \" 6. This team has positioned itself well for continued success.\",  \n                    \" 7. This team has the ability to perform well in the future. \", \n                    \" 8. This team has the ability to function as an ongoing unit.\" , \n                    \" 9. This team should continue to function as a unit. \", \n                    \" 10. This team has the resources to perform well in the future. \", \n                    \" 11. This team is well positioned for growth over time. \", \n                    \" 12. This team can develop to meet future challenges. \", \n                    \" 13. This team has the capacity to sustain itself. \", \n                    \" 14. This team has what it takes to endure in future performance episodes.\", \"condition\", \"results.condition\") \nnames(viabilityLikert) <- rep(viabilityLabels) \n\n## Likert graph for all viability responses across all conditions (i.e. baseline, control and treatment): \nlikert.out <- likert(viabilityLikert[-c(15:16)]) \nplot(likert.out)\n\n## Subset A and Ap (i.e. A prime) responses for treatment group: \n# Treatment + A: \ntreatmentA <- viabilityLikert %>% filter(condition==\"A\" & results.condition==\"treatment\") \nlikert.treatmentA <- likert(treatmentA[-c(15:16)])\nplot(likert.treatmentA)\nplot(likert.treatmentA,\ttype='density')\n\n# Treatment + Ap: \ntreatmentAp <- viabilityLikert %>% filter(condition==\"Ap\" & results.condition==\"treatment\") \nlikert.treatmentAp <- likert(treatmentA[-c(15:16)])\nplot(likert.treatmentAp)\nplot(likert.treatmentAp,\ttype='density')\n\n## Customize code above to filter on other conditions and treatments of interest. \n\n## Create a new dataframe that converts factors to numeric for statistical analyses: \nstats <- clean %>% mutate_if(is.factor, as.numeric)\nfor (i in 1:nrow(stats)) {\n  stats$sum[i] <- sum(stats[i,1:14])                          \n} \nstats$mean <- mean(stats$sum)\nstats$mean <- median(stats$sum)\n\n## Examples of how to subset visualize mean distribution for a specific condition and treatment (example case: treatment with all conditions)\ntreatmentAStats <- stats %>% filter(results.condition==\"treatment\" & condition==\"A\") \n\nfor (i in 1:nrow(treatmentAStats)) {\n  treatmentAStats$sum[i] <- sum(treatmentAStats[,1:14])                          \n} \ntreatmentAStats$mean <- mean(treatmentAStats$sum) \ntreatmentAStats$median <- median(treatmentAStats$sum)\n\ntreatmentBStats <- subset(stats,results.condition==\"treatment\",condition==\"B\")\nfor (i in 1:nrow(treatmentBStats)) {\n  treatmentBStats$sum[i] <- sum(treatmentBStats[i,1:14])                          \n} \ntreatmentBStats$mean <- mean(treatmentBStats$sum) \ntreatmentBStats$median <- median(treatmentBStats$sum)\n\ntreatmentApStats <- subset(stats, results.condition==\"treatment\", condition==\"Ap\")\nfor (i in 1:nrow(treatmentApStats)) {\n  treatmentApStats$sum[i] <- sum(treatmentApStats[i,1:14])                          \n} \ntreatmentApStats$mean <- mean(treatmentApStats$sum) \ntreatmentApStats$median <- median(treatmentApStats$sum)\n\n## Mean viability distribution graph: treatment condition, A group \nbarfill <- \"#4271AE\"\nbarlines <- \"#1F3552\"\n## Mean for treatment and A group: ##fill-in) \nmeanViabilityDistributionUnMasked <- ggplot(treatmentAStats, aes(x = sum)) +\n  geom_histogram(aes(y = ..count..), binwidth = 5,\n                 colour = barlines, fill = barfill) +\n  scale_x_continuous(name = \"Median viability sum\",\n                     breaks = seq(0, 100, 20),\n                     limits=c(0, 70)) +\n  scale_y_continuous(name = \"count\") +\n  ggtitle(\"Frequency of sum of viability scores: N=##fill-in\") +\n  theme_bw() +\n  theme(axis.line = element_line(size=1, colour = \"black\"),\n        panel.grid.major = element_line(colour = \"#d3d3d3\"),\n        panel.grid.minor = element_blank(),\n        panel.border = element_blank(), panel.background = element_blank(),\n        plot.title = element_text(size = 14, family = \"Tahoma\", face = \"bold\"),\n        text=element_text(family=\"Tahoma\"),\n        axis.text.x=element_text(colour=\"black\", size = 9),\n        axis.text.y=element_text(colour=\"black\", size = 9)) +\n  geom_vline(xintercept = ##fill-in, size = 1, colour = \"#FF3721\",\n               linetype = \"dashed\")\nmeanViabilityDistributionUnMasked \n\n## Mean viability distribution graph: treatment condition, Aprime group \n## Mean for treatment condition, Aprime group: (fill-in)\nmeanViabilityDistributionControl <- ggplot(treatmentApStats, aes(x = sum)) +\n  geom_histogram(aes(y = ..count..), binwidth = 5,\n                 colour = barlines, fill = barfill) +\n  scale_x_continuous(name = \"Median viability sum\",\n                     breaks = seq(0, 100, 20),\n                     limits=c(0, 70)) +\n  scale_y_continuous(name = \"count\") +\n  ggtitle(\"Frequency of sum of viability scores:N=##fill-in\") +\n  theme_bw() +\n  theme(axis.line = element_line(size=1, colour = \"black\"),\n        panel.grid.major = element_line(colour = \"#d3d3d3\"),\n        panel.grid.minor = element_blank(),\n        panel.border = element_blank(), panel.background = element_blank(),\n        plot.title = element_text(size = 14, family = \"Tahoma\", face = \"bold\"),\n        text=element_text(family=\"Tahoma\"),\n        axis.text.x=element_text(colour=\"black\", size = 9),\n        axis.text.y=element_text(colour=\"black\", size = 9)) +\n  geom_vline(xintercept = ##fill-in, size = 1, colour = \"#FF3721\",\n               linetype = \"dashed\")\nmeanViabilityDistributionControl\n\n## Mean viability distribution graph: treatment condition, B group \n## Mean for treatment condition, B group: \nbarfill <- \"#4271AE\"\nbarlines <- \"#1F3552\"\nmeanViabilityDistributionMasked <- ggplot(treatmentBStats, aes(x = sum)) +\n  geom_histogram(aes(y = ..count..), binwidth = 5,\n                 colour = barlines, fill = barfill) +\n  scale_x_continuous(name = \"Median viability sum \\n across all teams in masked round\",\n                     breaks = seq(0, 98, 14),\n                     limits=c(7, 70)) +\n  scale_y_continuous(name = \"count\") +\n  ggtitle(\"Frequency of sum of viability scores: masked condition, N=##fill-in\") +\n  theme_bw() +\n  theme(axis.line = element_line(size=1, colour = \"black\"),\n        panel.grid.major = element_line(colour = \"#d3d3d3\"),\n        panel.grid.minor = element_blank(),\n        panel.border = element_blank(), panel.background = element_blank(),\n        plot.title = element_text(size = 14, family = \"Tahoma\", face = \"bold\"),\n        text=element_text(family=\"Tahoma\"),\n        axis.text.x=element_text(colour=\"black\", size = 9),\n        axis.text.y=element_text(colour=\"black\", size = 9)) +\n  geom_vline(xintercept = ##fill-in, size = 1, colour = \"#FF3721\",\n               linetype = \"dashed\") \nmeanViabilityDistributionMasked\n\n## Boxplot distribution of viability scale sums and repeat team question (example case with treatment and A, Ap and B conditions): \n\ng <- ggplot(treatmentAStats, aes(factor(repeatTeam, labels = c(\"Yes\", \"No\")), sum))\ng + geom_boxplot(varwidth=T, fill=\"plum\") + \n  labs(subtitle=\"Sum of viability measures grouped by repeat team question in treatment condition, A group\", \n       x=\"If you had the choice, would you like to work with the same team in a future round? \",\n       y=\"Numeric sum of viability measures questions (range: 7-70)\")\n\ng <- ggplot(treatmentBStats, aes(factor(repeatTeam, labels = c(\"Yes\", \"No\")), sum))\ng + geom_boxplot(varwidth=T, fill=\"plum\") + \n  labs(subtitle=\"Sum of viability measures grouped by repeat team question in treatment condition, B group\", \n       x=\"If you had the choice, would you like to work with the same team in a future round? \",\n       y=\"Numeric sum of viability measures questions (range: 7-70)\")\n\ng <- ggplot(treatmentApStats, aes(factor(repeatTeam, labels = c(\"Yes\", \"No\")), sum))\ng + geom_boxplot(varwidth=T, fill=\"plum\") + \n  labs(subtitle=\"Sum of viability measures grouped by repeat team question in treatment condition, Ap group\", \n       x=\"If you had the choice, would you like to work with the same team in a future round? \",\n       y=\"Numeric sum of viability measures questions (range: 7-70)\")\n\nggplot(fractureLE, aes(prop, prop1)) +\n  geom_point(aes(shape=results.condition)) +\n  geom_jitter() + coord_fixed() + xlim(0.0,1.0) + ylim(0.0,1.0) + labs(title=\"Team fracture in first vs. third round in learning effect condition\", subtitle=\"Fracture scale 0=no fracture, 1=fracture\",  \n                                                                       x=\"Fracture the first time a team interacts\", \n                                                                       groupedProportionFracture <- groupedProportion %>%\n                                                                         mutate(fracture = case_when(prop<=.50 ~ \"0\", prop>.50 ~ \"1\")) %>% \n                                                                         filter(results.condition==\"treatment\" & condition==\"A\" || condition==\"Ap\")                                                                 y=\"Fracture the second time a team interacts, without knowing it\") \ngroupedProportionFracture <- groupedProportion %>%\n  mutate(fracture = case_when(prop<=.50 ~ \"0\", prop>.50 ~ \"1\")) %>% \n  filter(results.condition==\"treatment\" & condition==\"A\" || condition==\"Ap\")\nfracture1 <- groupedProportionFracture %>% filter(condition==\"A\")\nfracture2 <- groupedProportionFracture %>% filter(condition==\"Ap\")\n\nfracture <- cbind(fracture1, fracture2)\nfracture$prop <- 1-fracture$prop\nfracture$prop1 <- 1-fracture$prop1\n\nggplot(treatmentFracture, aes(prop1, prop2)) +\n  geom_point() +\n  geom_jitter() + coord_fixed() + xlim(0.0,1.0) + ylim(0.0,1.0) + labs(title=\"Team fracture in the first round vs. fracture in the experimental round\", subtitle=\"Fracture scale 0=no fracture, 1=fracture\",  \n                                                                       x=\"Fracture the first time a team interacts\", \n                                                                       y=\"Fracture the second time a team interacts, without knowing it\") \n\n\nggplot(controlFracture, aes(prop, prop1)) +\n  geom_point() +\n  geom_jitter() + coord_fixed() + xlim(0.0,1.0) + ylim(0.0,1.0) + labs(title=\"Team fracture in the first vs. in the second, control round, n=7 teams\", subtitle=\"Fracture scale 0=no fracture, 1=fracture\",  \n                                                                       x=\"Fracture the first time a team interacts\", \n                                                                       y=\"Fracture the second time a team interacts, without knowing it\") \n\n\n\n## Proportion graphs for Q15: \n## Revalue repeat team: keep plyr b/c some weird R stuff requires library to be called directly: \nstats$repeatTeam <- plyr::revalue(stats$repeatTeam, c(\"Yes\"=\"1\", \"No\"=\"0\"))\n## Convert to compatible classes for grouping: \nstats$repeatTeam <- as.numeric(stats$repeatTeam)\nstats$room <- unlist(stats$room) \n\n## MSB: is there another way to group_by teams using base R: I'm skeptical of dplyr. If not, triple check computations are accurate below: \n\n## Table with mean sum for condition (i.e. treatment, baseline, control) and condition format:\nxtabs(mean ~ condition + results.format, data=stats) \n\n## Subset on the fly (from group_by data)\nxtabs(prop ~ round + batch + room, data=groupedProportion, subset = condition==\"treatment\")\nxtabs(prop ~ group + batch + room, data=stats, subset = condition==\"control\")\nxtabs(prop ~ group + batch + room, data=stats, subset = condition==\"baseline\")\n\n## Subset proportions:  \n\ngroupedProportion <- stats %>% group_by(round, room, batch, condition, results.condition) %>%\n  summarise(n=n(), prop=sum(repeatTeam)/n, mean=mean(sum), median=median(sum)) %>% filter(n>1)\n\ngroupedProportion <- stats %>% group_by(round, room, batch) %>%\n  summarise(n=n(), prop=prop.table(repeatTeam) %>% filter(n>1))\n\nindividualProportion <- stats %>% group_by(round, batch, room) %>% \n  mutate(sum=sum, mean=mean(sum), median=median(sum), n=n(),prop=sum(repeatTeam)/n) %>% filter(n>1)\n\n## Alternatives: \n\ngroupedProportion2 <- plyr::ddply(stats, .list(batch, round, room), summarise, n=n(), prop = sum(repeatTeam)/n)\ngroupedProportion2 <- groupedProportion %>% filter(n>1)\n\ngroupedProportion <- stats %>% group_by(round, room, batch, condition, results.condition) %>%\n  summarise(n=n(), prop=sum(repeatTeam)/n, mean=mean(sum), median=median(sum)) %>% filter(n>1)\n\nggplot(data=groupedProportion, aes(groupedProportion$prop, fill=factor(condition))) + \n  geom_histogram(breaks=seq(0, 1, by=0.20), \n                 col=\"red\", \n                 fill=\"green\", \n                 alpha=.2) + labs(title=\"Binary proportion of answers for question 15 per team (team size range: 2-4) n=##fill-in teams\", \n                                  x=\"If you had the choice, would you like to work with the same team in a future round? \n                                  1=Yes , 0=No\", y=\"Count\") \n\nggplot(data=individualProportion, aes(individualProportion$prop)) + \n  geom_histogram(breaks=seq(0, 1, by=0.20), \n                 col=\"red\", \n                 fill=\"green\", \n                 alpha=.2) + labs(title=\"Binary proportion of answers for question 15 per team: n=##fill-in observations\",\n                                  x=\"If you had the choice, would you like to work with the same team in a future round? \n                                  1=Yes , 0=No\", y=\"Count\") \n\n\ngroupedProportionFracture <- groupedProportion %>%\n  mutate(fracture = case_when(prop<=.50 ~ \"0\", prop>.50 ~ \"1\")) %>% \n  filter(results.condition==\"treatment\" & condition==\"A\" || condition==\"Ap\")\n\nfracture1 <- groupedProportionFracture %>% filter(condition==\"A\")\nfracture2 <- groupedProportionFracture %>% filter(condition==\"Ap\")\nplot(fracture1$prop,fracture2$prop)\n\nfracture <- cbind(fracture1, fracture2)\nfracture$prop <- 1-fracture$prop\nfracture$prop1 <- 1-fracture$prop1\n\n## how many teams have a 1 in both columns \n## how many have in both \n## how many have none \n\n\nggplot(fracture, aes(prop, prop1)) +\n  geom_point() +\n  geom_jitter() + coord_fixed() + xlim(0,1) + ylim(0,1) + labs(subtitle=\"Fracture proportions\", \n                                                               x=\"Fracture round A: the first time a team interacts\", \n                                                               y=\"Fracture round Ap: the second time a team interacts, without knowing it\") \n\ngroupedProportionFracture$fracture <- as.numeric(groupedProportionFracture$fracture)\ntally(~condition + fracture, data = groupedProportionFracture, format = \"proportion\")\ntally(~fracture | condition, data = groupedProportionFracture, format = \"proportion\")\n\n\n## Distribution of median vs. mean per team: \nqplot(mean, prop, data=groupedProportion, \n      main=\"Scatterplots median vs. mean for viability sum responses per team\",\n      xlab=\"mean\", ylab=\"median\")\n\nggplot(groupedProportion, aes(x=prop, y=mean)) + \n  geom_point() +\n  stat_smooth(method = \"lm\", col = \"red\")\n\n## Indivdiaul proportion with sum:  \nfit1 <- lm(mean ~ prop, data = individualProportion, se=TRUE)\nsummary(fit1)\nplot(mean ~ prop, data = individualProportion)\nabline(fit1, )\n\nfit1 <- lm(sum ~ prop, data = individualProportion)\nsummary(fit1)\nplot(sum ~ prop, data = individualProportion)\nabline(fit1)\n\nfit1 <- lm(median ~ prop, data = groupedProportion)\nsummary(fit1)\nplot(median ~ prop, data = groupedProportion)\nabline(fit1)\n\n## Group proportion with sum: \nfit1 <- lm(mean ~ prop, data = groupedProportion)\nsummary(fit1)\nplot(mean ~ prop, data = groupedProportion)\nabline(fit1)\n\nfit1 <- lm(median ~ prop, data = groupedProportion)\nsummary(fit1)\nplot(median ~ prop, data = groupedProportion)\nabline(fit1)\n\n## Basic exploratory stats testing: \n## Parametric inference: \nhist(stats$sum,xlab=\"Sum of scores\",main=\"\")\n\n## Depending on the results from this test, we can determine if we are justified in using a parametric test. \n## If, data passes normality tests, then we can use the following tests: \n## T-Test. We can use a two-sample T-test to asses if there is a difference in the scores of specific groups:\n## Examples: \n## First use a boxplot for visualization to identify a relationship. \n\n## If normality assumptions are met: \n## Is there a significant difference between viability sums between conditions: masked // unmasked? \n\npairedTest <-  subset(stats, condition==\"masked\" | condition==\"unmasked\") \nt.test(sum~condition, data=pairedTest)\n\n## Import and clean chat data from database: \n+## Chat data import: \n  \nchatFiles = lapply(completeBatches, function(batch){\n    chatFile = read_json(paste(dataPath,batch,\"chats.json\",sep=\"/\"), simplifyVector = TRUE)\n    return(flatten(chatFile, recursive = TRUE))\n  })\n\nallChatFiles <- ldply(chatFiles, data.frame)\nchatFreq <- allChatFiles  %>%\n  select(round, room, batch) %>% \n  group_by(round, room, batch) %>% \n  dplyr::summarise(n=n()) %>% \n  mutate(sum=prop.table(repeatTeam)) %>% \n  filter(n>1, round<=2)\n\nggplot(fractureLE, aes(prop, prop1)) +\n  geom_point(aes(shape=results.condition)) +\n  geom_jitter() + coord_fixed() + xlim(0.0,1.0) + ylim(0.0,1.0) + labs(title=\"Team fracture in first round vs. third in learning effect condition\", subtitle=\"Fracture scale 0=no fracture, 1=fracture\",  \n                                                                       x=\"Fracture the first time a team interacts\", \n                                                                       y=\"Fracture the second time a team interacts, without knowing it\") \n\n## Filter on round <=2, because round 3 in all but one case is only includes \"X has left chat room\" \n\n# Histogram grouped by round: \ng <- ggplot(chatFreq, aes(n)) + scale_fill_brewer(palette = \"Spectral\")\ng + geom_histogram(aes(fill=factor(round)), \n                   bins=5, \n                   col=\"black\", \n                   size=.1) +   # change number of bins\n  labs(title=\"Histogram of chat line length per team (includes teams with n=1)\", \n       fill = \"Round\") + \n  xlab(label=\"Number of lines from chat data per team\") + \n  ylab(label=\"Count\") \nstats$room <- unlist(stats$room) \nchatFreqStats <- right_join(x=chatFreq, y=stats)\n\n# Histogram grouped by round: \ng <- ggplot(chatFreq, aes(n)) + scale_fill_brewer(palette = \"Spectral\")\ng + geom_histogram(aes(fill=factor(round)), \n                   bins=5, \n                   col=\"black\", \n                   size=.1) +   # change number of bins\n  labs(title=\"Histogram of chat line length per team (includes teams with n=1)\", \n       fill = \"Round\") + \n  xlab(label=\"Number of lines from chat data per team\") + \n  ylab(label=\"Count\") \n\ng <- ggplot(treatmentFracture, aes(abs)) + scale_fill_brewer(palette = \"Spectral\")\ng + geom_histogram(bins=7, \n                   col=\"pink\", \n                   size=.4) + \n  labs(title=\"Absolute value of change in team fracture proportions between unmasked and masked\", \n       fill = \"Round\") + \n  xlab(label=\"Absolute value of change in team fracture proportions between unmasked and masked \") + \n  ylab(label=\"Count\") \n\nlibrary(ggplot2)\ntheme_set(theme_bw())  \n\n# Data Prep\n\nmtcars$`car name` <- rownames(mtcars)  # create new column for car names\nmtcars$mpg_z <- round((groupedProportionFractureTreatment$fracture - mean(groupedProportionFractureTreatment$fracture))/sd(groupedProportionFractureTreatment$fracture), 2)  # compute normalized mpg\nmtcars$mpg_type <- ifelse(mtcars$mpg_z < 0, \"below\", \"above\")  # above / below avg flag\nmtcars <- mtcars[order(mtcars$mpg_z), ]  # sort\nmtcars$`car name` <- factor(mtcars$`car name`, levels = mtcars$`car name`)  # convert to factor to retain sorted order in plot.\n\n# Diverging Barcharts\nggplot(mtcars, aes(x=`car name`, y=mpg_z, label=mpg_z)) + \n  geom_bar(stat='identity', aes(fill=mpg_type), width=.5)  +\n  scale_fill_manual(name=\"Mileage\", \n                    labels = c(\"Above Average\", \"Below Average\"), \n                    values = c(\"above\"=\"#00ba38\", \"below\"=\"#f8766d\")) + \n  labs(subtitle=\"Normalised mileage from 'mtcars'\", \n       title= \"Diverging Bars\") + \n  coord_flip()\n\ng <- ggplot(data, aes(x=main_category, fill=factor(state)))\ng+ geom_bar(position=\"dodge\") +\n  xlab(label=\"Main Category\") +\n  ylab(label=\"Number of Backers\") + \n  labs(title=\"Backers by Category\" , fill = \"State of Campaign\")\n\n\n\n",
    "created" : 1536901869445.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3745438691",
    "id" : "699C3F9F",
    "lastKnownWriteTime" : 1535779551,
    "last_content_update" : 1535779551,
    "path" : "~/Documents/bang9/R/bangCodeBook.R",
    "project_path" : "bangCodeBook.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}